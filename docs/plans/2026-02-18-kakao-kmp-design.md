# kakao-kmp: KMP UI Testing Library Design

## Overview

A Kotlin Multiplatform UI testing library inspired by Kakao Compose, built on top of Compose Multiplatform Test API. Provides Page Object pattern, Flaky Safety, and Allure TestOps integration — all from a single `commonMain` codebase with **zero expect/actual**.

**Module**: `:kakao-kmp` (monolith, inside this repository)
**Targets**: Android + iOS (same as the host project)
**Gradle plugin**: `com.android.library` + `kotlin("multiplatform")` — uses `androidTarget()` to match the consumer `:composeApp`

## Goals

1. **Page Object pattern** — `KmpScreen` / `KNode` typed DSL for reusable screen definitions
2. **Flaky Safety** — automatic retry for actions and assertions with configurable timeout, inheritance-aware exception matching
3. **Allure integration** — `allureId()`, `feature()`, `epic()`, `step()` DSL + JSON report generation with nested step support

## Non-Goals (first iteration)

- KSP plugin for annotation-to-DSL sync
- Screenshot attachments in Allure reports
- Custom Gradle plugin for result collection
- Compatibility with Espresso or XCUITest

## Key Design Decision: DSL over Annotations

Kotlin/Native (iOS) has no runtime reflection — `@AllureId("TC-123")` cannot be read at runtime. Instead, metadata is declared via DSL calls inside the test body:

```kotlin
@Test
fun createCardFlow() = kakaoTest(testName = "createCardFlow") {
    allureId("TC-123")
    feature("Cards")
    // ...
}
```

Note: `testName` should be passed explicitly for Kotlin/Native (iOS) compatibility. On JVM, automatic inference from the stack trace works but is not guaranteed. The fallback value is `"UnknownTest"`.

Allure-compatible JSON is generated by our own writer using `kotlinx-serialization` + `kotlinx-io`, without depending on `allure-kotlin` (JVM-only).

## API: How Tests Look

### Screen Definitions (Page Objects)

```kotlin
class HomeScreen(test: ComposeUiTest) : KmpScreen<HomeScreen>(test) {
    val createButton = KNode { hasTestTag(UiTags.HomeCreateCardButton) }
    fun cardWithText(text: String) = KNode { hasText(text) }

    companion object : KmpScreenFactory<HomeScreen>(::HomeScreen)
}

class CreateCardScreen(test: ComposeUiTest) : KmpScreen<CreateCardScreen>(test) {
    val firstNameField = KNode { hasTestTag(UiTags.CreateFirstNameField) }
    val lastNameField = KNode { hasTestTag(UiTags.CreateLastNameField) }
    val submitButton = KNode { hasTestTag(UiTags.CreateSubmitButton) }
    val backButton = KNode { hasTestTag(UiTags.CreateBackButton) }

    companion object : KmpScreenFactory<CreateCardScreen>(::CreateCardScreen)
}
```

### Test

```kotlin
@Test
fun createCardFlow() = kakaoTest(testName = "createCardFlow") {
    allureId("TC-123")
    feature("Cards")

    setContent { App(root = root) }

    step("[1] Нажать \"Создать карточку\"") {
        HomeScreen {
            createButton.click()
        }
    }
    step("[2] Ввести имя и фамилию") {
        CreateCardScreen {
            firstNameField.typeText("TestName")
            lastNameField.typeText("TestSurname")
        }
    }
    step("[3] Нажать \"Создать\"") {
        CreateCardScreen {
            submitButton.click()
        }
    }
    step("[4] Проверить, что карточка появилась на главном") {
        HomeScreen {
            cardWithText("TestName TestSurname").assertIsDisplayed()
        }
    }
}
```

### Key API Features

- `HomeScreen { }` works directly (no `onScreen<>`) — enabled by `KmpScreenFactory` companion + `TestScope` extension operator
- `step()` integrates with Allure lifecycle — each step is recorded with status and timing; nested steps are supported via an internal `ArrayDeque` stack
- On step failure, the Compose semantics tree is dumped to logcat/stdout for debugging (same behavior as the existing `Steps.kt`)
- Every KNode action/assertion is flaky-safe by default
- Exception matching uses `KClass.isInstance()` for proper inheritance support

## Architecture

### Module Structure

```
kakao-kmp/src/commonMain/kotlin/io/github/kakaokmp/
├── screen/
│   └── KmpScreen.kt            — abstract base Page Object + KmpScreenFactory
├── node/
│   ├── KNode.kt                — typed UI element with flaky-safe actions/assertions
│   └── MatcherBuilder.kt       — DSL for composing SemanticsMatcher
├── safety/
│   ├── FlakySafety.kt          — retry via TimeSource.Monotonic + waitForIdle()
│   ├── FlakySafetyTimeoutException.kt
│   └── KakaoKmpConfig.kt       — global defaults (timeout, interval, allowed exceptions)
├── dsl/
│   ├── TestScope.kt            — receiver for kakaoTest/step, delegates ComposeUiTest
│   └── KakaoTest.kt            — fun kakaoTest() entry point + inferTestName()
├── allure/
│   ├── model/
│   │   ├── AllureTestResult.kt
│   │   ├── AllureStepResult.kt
│   │   ├── AllureLabel.kt
│   │   ├── AllureStatus.kt
│   │   └── AllureStatusDetails.kt
│   ├── AllureLifecycle.kt      — runtime result collector with nested step stack
│   └── AllureWriter.kt         — JSON file writer via kotlinx-io
└── matchers/
    └── Matchers.kt             — re-exports for MatcherBuilder (hasTestTag, hasText, ...)
```

Note: `KmpScreenFactory` is merged into `KmpScreen.kt` (it is only 3 lines). No separate file.

No `androidMain/` or `iosMain/` source sets needed — everything is in `commonMain`.

### Component Graph

```
kakaoTest { }
    └── TestScope (delegates ComposeUiTest)
            ├── step() ──→ AllureLifecycle.startStep() / stopStep()
            │              └── on failure: onRoot().printToLog("SemanticsTree")
            ├── allureId(), feature() ──→ AllureLifecycle.addLabel()
            └── HomeScreen { } ──→ KmpScreenFactory.invoke()
                    └── KmpScreen(ComposeUiTest)
                            └── KNode(ComposeUiTest, SemanticsMatcher)
                                    ├── click()       ─┐
                                    ├── typeText()     ├─→ flakySafely { }
                                    ├── assertIsDisplayed() ─┘
                                    └── interaction() → onNode(matcher)

AllureLifecycle (ArrayDeque<StepEntry> for nesting)
    └── finishTest() → AllureWriter.write(result)
                            └── kotlinx-io SystemFileSystem → JSON file
```

### Core Classes

#### KmpScreen

```kotlin
abstract class KmpScreen<T : KmpScreen<T>>(
    internal val composeUiTest: ComposeUiTest
) : SemanticsNodeInteractionsProvider by composeUiTest {

    fun KNode(matcherBlock: MatcherBuilder.() -> Unit): KNode =
        KNode(composeUiTest, MatcherBuilder().apply(matcherBlock).build())
}
```

#### KmpScreenFactory (defined in `KmpScreen.kt`)

```kotlin
open class KmpScreenFactory<T : KmpScreen<T>>(
    internal val create: (ComposeUiTest) -> T
)
```

Inside `TestScope`, the extension operator makes `Screen { }` work:

```kotlin
class TestScope(
    val composeUiTest: ComposeUiTest,
    val allureLifecycle: AllureLifecycle = AllureLifecycle()
) : ComposeUiTest by composeUiTest {

    operator fun <T : KmpScreen<T>> KmpScreenFactory<T>.invoke(block: T.() -> Unit) {
        create(composeUiTest).block()
    }
}
```

#### KNode

```kotlin
class KNode(
    private val composeUiTest: ComposeUiTest,
    private val matcher: SemanticsMatcher
) {
    // Actions (all flaky-safe)
    fun click() = composeUiTest.flakySafely {
        composeUiTest.onNode(matcher).performClick()
    }
    fun typeText(text: String) = composeUiTest.flakySafely {
        composeUiTest.onNode(matcher).performTextInput(text)
    }
    fun scrollTo() = composeUiTest.flakySafely {
        composeUiTest.onNode(matcher).performScrollTo()
    }

    // Assertions (all flaky-safe)
    fun assertIsDisplayed() = composeUiTest.flakySafely {
        composeUiTest.onNode(matcher).assertIsDisplayed()
    }
    fun assertTextEquals(expected: String) = composeUiTest.flakySafely {
        composeUiTest.onNode(matcher).assertTextEquals(expected)
    }
    fun assertIsEnabled() = composeUiTest.flakySafely {
        composeUiTest.onNode(matcher).assertIsEnabled()
    }
}
```

#### MatcherBuilder

```kotlin
class MatcherBuilder {
    private val matchers = mutableListOf<SemanticsMatcher>()

    fun hasTestTag(tag: String) { matchers += androidx.compose.ui.test.hasTestTag(tag) }
    fun hasText(text: String) { matchers += androidx.compose.ui.test.hasText(text) }
    fun hasContentDescription(desc: String) {
        matchers += androidx.compose.ui.test.hasContentDescription(desc)
    }

    internal fun build(): SemanticsMatcher {
        check(matchers.isNotEmpty()) { "MatcherBuilder requires at least one matcher" }
        return matchers.reduce { a, b -> a and b }
    }
}
```

#### FlakySafety

```kotlin
object KakaoKmpConfig {
    var defaultTimeoutMs: Long = 5_000L
    var defaultIntervalMs: Long = 500L  // reserved for future non-Compose retry functions
    var allowedExceptions: Set<KClass<out Throwable>> = setOf(
        AssertionError::class,
        IllegalStateException::class,
    )
}

inline fun <T> ComposeUiTest.flakySafely(
    timeoutMs: Long = KakaoKmpConfig.defaultTimeoutMs,
    allowedExceptions: Set<KClass<out Throwable>> = KakaoKmpConfig.allowedExceptions,
    block: () -> T
): T {
    require(timeoutMs > 0) { "timeoutMs must be positive, was $timeoutMs" }

    val mark = TimeSource.Monotonic.markNow()
    var lastError: Throwable? = null
    while (mark.elapsedNow() < timeoutMs.milliseconds) {
        try {
            return block()
        } catch (e: Throwable) {
            // Uses isInstance() for inheritance-aware matching
            if (allowedExceptions.none { it.isInstance(e) }) throw e
            lastError = e
            waitForIdle()
        }
    }
    throw FlakySafetyTimeoutException(timeoutMs, lastError!!)
}

// Standalone version for unit testing the retry logic (no Compose dependency).
// Uses spin-wait because Thread.sleep() is unavailable in Kotlin common.
inline fun <T> flakySafelyPlain(
    timeoutMs: Long = KakaoKmpConfig.defaultTimeoutMs,
    allowedExceptions: Set<KClass<out Throwable>> = KakaoKmpConfig.allowedExceptions,
    block: () -> T
): T {
    require(timeoutMs > 0) { "timeoutMs must be positive, was $timeoutMs" }
    // ... same loop without waitForIdle() ...
}
```

Key design points:
- `require(timeoutMs > 0)` prevents NPE from `lastError!!` when timeout is zero or negative.
- `allowedExceptions.none { it.isInstance(e) }` checks via inheritance, not exact class match. A `FlakySafetyTimeoutException` (subclass of `AssertionError`) would also be caught — do not nest `flakySafely` calls.
- `ComposeUiTest.flakySafely` uses `waitForIdle()` between retries (Compose-driven pause). `flakySafelyPlain` uses spin-wait (acceptable for unit tests only).

#### kakaoTest entry point

```kotlin
@OptIn(ExperimentalTestApi::class)
fun kakaoTest(
    testName: String? = null,
    block: TestScope.() -> Unit
) = runComposeUiTest {
    val lifecycle = AllureLifecycle()
    val scope = TestScope(this, lifecycle)
    val name = testName ?: inferTestName()

    lifecycle.startTest(name)
    try {
        scope.block()
        lifecycle.finishTest(AllureStatus.PASSED)
    } catch (e: Throwable) {
        lifecycle.finishTest(AllureStatus.FAILED, e)
        throw e
    } finally {
        AllureWriter.write(lifecycle.buildResult())
    }
}
```

Note: `AllureWriter.write()` is in `finally` block to ensure results are written even on test failure.

#### inferTestName

```kotlin
internal fun inferTestName(): String {
    val trace = Throwable().stackTraceToString()
    val testLine = trace.lineSequence()
        .firstOrNull { line ->
            line.contains("Test.") && !line.contains("kakaoTest") && !line.contains("inferTestName")
        }
    return testLine
        ?.trim()
        ?.substringAfter("at ")
        ?.substringBefore("(")
        ?: "UnknownTest"
}
```

**Kotlin/Native limitation:** `Throwable().stackTraceToString()` produces a different format on Native. The function returns `"UnknownTest"` as fallback. Always pass `testName` explicitly for cross-platform reliability.

### Allure JSON Model

Minimal set of `@Serializable` data classes matching the Allure 2 result format:

```kotlin
@Serializable
data class AllureTestResult(
    val uuid: String,                              // kotlin.uuid.Uuid.random()
    val name: String,
    val fullName: String,
    val status: AllureStatus,
    val start: Long,                               // epoch ms via kotlinx-datetime
    val stop: Long,
    val labels: List<AllureLabel> = emptyList(),
    val steps: List<AllureStepResult> = emptyList(),
    val statusDetails: AllureStatusDetails? = null,
)

@Serializable
data class AllureStepResult(
    val name: String,
    val status: AllureStatus,
    val start: Long,
    val stop: Long,
    val steps: List<AllureStepResult> = emptyList(),   // nested steps
)

@Serializable
data class AllureLabel(val name: String, val value: String)

@Serializable
data class AllureStatusDetails(val message: String? = null, val trace: String? = null)

@Serializable
enum class AllureStatus {
    @SerialName("passed") PASSED,
    @SerialName("failed") FAILED,
    @SerialName("broken") BROKEN,
    @SerialName("skipped") SKIPPED,
}
```

Label conventions: `AS_ID` for allure test case ID, `feature`, `epic`, `story` for hierarchy.

### AllureLifecycle (with nested step support)

```kotlin
class AllureLifecycle {
    private val steps = mutableListOf<AllureStepResult>()

    // Stack for nested step support
    private data class StepEntry(
        val name: String,
        val start: Long,
        val children: MutableList<AllureStepResult> = mutableListOf(),
    )
    private val stepStack = ArrayDeque<StepEntry>()

    fun startStep(name: String) {
        stepStack.addLast(StepEntry(name = name, start = now()))
    }

    fun stopStep(status: AllureStatus, error: Throwable? = null) {
        val entry = stepStack.removeLast()
        val result = AllureStepResult(
            name = entry.name,
            status = status,
            start = entry.start,
            stop = now(),
            steps = entry.children.toList(),
        )
        // Attach to parent step or top-level list
        val parent = stepStack.lastOrNull()
        if (parent != null) {
            parent.children += result
        } else {
            steps += result
        }
    }
    // ...
}
```

### AllureWriter

```kotlin
object AllureWriter {
    /**
     * Output directory for Allure JSON files.
     * Default: "allure-results" (relative to working directory).
     *
     * On mobile targets the working directory may vary:
     * - Android testDebugUnitTest: module root
     * - iOS simulator: app sandbox
     *
     * Set to an absolute path for predictable output:
     *   AllureWriter.outputDir = "/tmp/allure-results"
     */
    var outputDir: String = "allure-results"

    fun write(result: AllureTestResult) {
        val dir = Path(outputDir)
        SystemFileSystem.createDirectories(dir)
        val file = Path(dir, "${result.uuid}-result.json")
        val json = Json { prettyPrint = true }.encodeToString(result)
        SystemFileSystem.sink(file).buffered().use { it.writeString(json) }
    }
}
```

## Gradle Configuration

### kakao-kmp/build.gradle.kts

```kotlin
plugins {
    alias(libs.plugins.kotlinMultiplatform)
    alias(libs.plugins.androidLibrary)        // android library, not application
    alias(libs.plugins.composeMultiplatform)
    alias(libs.plugins.composeCompiler)
    alias(libs.plugins.kotlinSerialization)
}

kotlin {
    androidTarget {                           // not jvm() — must match consumer
        compilerOptions {
            jvmTarget.set(JvmTarget.JVM_11)
        }
    }

    iosArm64()                                // no binaries.framework — this is a library
    iosSimulatorArm64()

    sourceSets {
        commonMain.dependencies {
            api(compose.uiTest)
            implementation(libs.kotlinx.serialization.json)  // reuses existing version catalog ref
            implementation(libs.kotlinx.io.core)
            implementation(libs.kotlinx.datetime)
        }
        commonTest.dependencies {
            implementation(libs.kotlin.test)
            implementation(libs.kotlinx.serialization.json)
        }
    }

    sourceSets.all {
        languageSettings.optIn("androidx.compose.ui.test.ExperimentalTestApi")
    }
}

android {
    namespace = "io.github.kakaokmp"
    compileSdk = libs.versions.android.compileSdk.get().toInt()
    defaultConfig {
        minSdk = libs.versions.android.minSdk.get().toInt()
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }
}
```

### Root build.gradle.kts

```kotlin
plugins {
    alias(libs.plugins.androidApplication) apply false
    alias(libs.plugins.androidLibrary) apply false
    alias(libs.plugins.composeMultiplatform) apply false
    alias(libs.plugins.composeCompiler) apply false
    alias(libs.plugins.kotlinMultiplatform) apply false
    alias(libs.plugins.kotlinSerialization) apply false   // add this
}
```

### Consumer opt-in (composeApp/build.gradle.kts)

Consumers should add global `ExperimentalTestApi` opt-in to avoid per-file `@OptIn` annotations:

```kotlin
kotlin {
    sourceSets.configureEach {
        languageSettings.optIn("androidx.compose.ui.test.ExperimentalTestApi")
    }
}
```

## Dependencies

```kotlin
// kakao-kmp/build.gradle.kts
commonMain.dependencies {
    api(compose.uiTest)
    implementation(libs.kotlinx.serialization.json)   // uses existing version ref
    implementation(libs.kotlinx.io.core)
    implementation(libs.kotlinx.datetime)
}
```

| Dependency | Why | KMP? |
|-----------|-----|------|
| compose.uiTest | ComposeUiTest, SemanticsNodeInteraction | Yes |
| kotlinx-serialization-json | Allure JSON encoding | Yes |
| kotlinx-io-core | File writing (SystemFileSystem) | Yes |
| kotlinx-datetime | Epoch timestamps for Allure | Yes |
| kotlin.uuid (stdlib 2.3.0) | UUID generation | Yes |
| kotlin.time (stdlib) | TimeSource for flaky safety | Yes |

## Why Zero expect/actual

| Concern | Common Solution |
|---------|----------------|
| File I/O | `kotlinx-io SystemFileSystem` |
| Timestamps | `kotlinx-datetime Clock.System` |
| UUID | `kotlin.uuid.Uuid` (Kotlin 2.3.0 stdlib) |
| Time measurement | `kotlin.time.TimeSource.Monotonic` |
| UI test API | `compose.uiTest` (multiplatform) |
| Compose sync | `ComposeUiTest.waitForIdle()` |

## Test Commands

| What | Command |
|------|---------|
| kakao-kmp unit tests | `./gradlew :kakao-kmp:testDebugUnitTest` |
| composeApp desktop tests | `./gradlew :composeApp:desktopTest` |
| composeApp all tests | `./gradlew :composeApp:allTests` |
| Full suite | `./gradlew :kakao-kmp:testDebugUnitTest :composeApp:desktopTest` |

## Future Improvements

- KSP plugin to auto-sync `@AllureId` annotation with `allureId()` DSL call
- Screenshot attachments via Compose `captureToImage()`
- `KLazyListNode` for typed lazy list testing (like Kakao Compose `KLazyListNode`)
- Allure environment/categories support
- Gradle plugin for automatic result collection from iOS simulators
- Interceptors (logging, custom pre/post hooks on actions)
- `Thread.sleep`-based interval for `flakySafelyPlain` via `actual` function if spin-wait becomes problematic
